<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<style type="text/css">
  .container{
    padding: 10px;
  }
</style>
<title>The JS9 Public API</title>
</head>
<body>
<div class="container">
<center><h3>The JS9 Public API</h3></center>

<p>
The JS9 Public API provides a JavaScript programming interface for
interacting with JS9. Obviously, all of JS9 JavaScript code is
available to you within a Web page, but the public API is designed to
stable and well-documented for users and Web designers. It also will
provide the basis for planned language bindings (python, perhaps C/Fortran).
<p>
In general, the public API routines act on the current image being
displayed in the default JS9 div element. Since most Web pages will
have only a single JS9 div element, this behavior is usually what you
want. It parallels DS9's behavior in which XPA commands act on the
currently displayed image. For example, to change the colormap of the
current image, use:
<pre>
  JS9.SetColormap("cool");
</pre>

<p>
However, for cases where multiple JS9 div elements are defined on a
single page, you can specify the specific div element to process by
adding an <b> display object</b> argument to the calling sequence with
a single <b>display</b> property:
<pre>
  {display: [div_id]}
</pre>
where [div_id] is the id of the target JS9 div element. For example,
if two JS9 divs with ids "JS9" and "myJS9", respectively, are present
on a single Web page, you can set the colormap of the second one this way:
<pre>
  JS9.SetColormap("cool", {display: "myJS9"})
</pre>
Note that this <b>display object</b> contains only the <b>display</b>
property and always is specified as the final argument in a call.
<p>
The display property can specify an image handle instead of
a JS9 div element id. This is a minor optimization for cases where you want
to call a routine such as JS9.WCSToPix() or JS9.PixtoWCS() many times:
<pre>
  var im = JS9.GetImage({display: "myJS9"});
  for(i=0; i<1000; i++){
    x = ...
    y = ... 
    wcs = JS9.PixtoWCS(x, y, {display: im});
    console.log("%s %s -> %s %s", x, y, wcs.ra, wcs.dec);
  }
</pre>
Passing the image handle will speed up processing very slightly, but
it makes us programmers feel much better.
<p>
The optional <b>display object</b> argument is not explicitly
documented in the routines below (except as an example
in <b>JS9.Load()</b>), but it is always available.

<p>
Choose from the following sections:
<ul>
<li><a href="#load">Loading Images</a>
<li><a href="#images">Working with Images</a>
<li><a href="#regions">Working with Regions</a>
<li><a href="#shapes">Working with Shape Layers</a>
<li><a href="#server">Server-side Analysis</a>
<li><a href="#misc">Miscellaneous</a>
<li><a href="#proto">Prototypes (in development)</a>
</ul>

<hr><p>
<center><b><font size="+1">
<a name="load">Loading Images</a>
</font></b></center>

<p>
<font size="+1"><b><u>Load an image into JS9</u></b></font>
<p> 
<code><font size="+1">JS9.Load(url, opts)</font></code>
<p>
where:
<ul>
<li><b>url</b>: url, fitsy object, in-memory FITS, or FITS blob
<li><b>opts</b>: object containing image parameters
</ul>
<p>
Load a FITS file or a PNG <b>representation file</b> into JS9.
You also can pass an in-memory buffer containing a FITS file, or a string
containing a base64-encoded FITS file.
<p>
Finally, you can pass a fits object containing the following properties:
<ul>
<li><b>naxis</b>: number of axes in the image
<li><b>axis</b>: array of image dimensions for each axis or ...
<li><b>naxis[n]</b> image dimensions of each axis (naxis1, naxis2, ...)
<li><b>bitpix</b>: FITS bitpix value
<li><b>head</b>: object containing header keywords as properties
<li><b>image</b>: typed data array containing image data (native format)
<li><b>dmin</b>: data min (optional)
<li><b>dmax</b>: data max (optional)
</ul>
The difference between <b>JS9.RefreshImage()</b> and <b>JS9.Load()</b> is
that the former updates the data into an existing image, while the latter adds
a completely new image to the display.
<p>
To override default image parameters, pass the image opts argument:
<pre>
    href='javascript:JS9.Load("png/m13.png", {scale:"linear", colormap:"sls"});'
</pre>
<p>
If an onload callback function is specified in opts, it will be called
after the image is loaded:
<pre>
    href='javascript:JS9.Load("fits/3c273.fits", {scale: "linear", onload: func});'
</pre>
The image handle is passed as the first argument to the callback.
<p>
To load an image into a specified display, pass the <b>display object</b> as the last argument:
<pre>
    href='javascript:JS9.Load("fits/3c273.fits", {scale: "linear"}, {display: "myJS9"});'
</pre>
<p>
See <a href="./yourdata.html">Displaying Your Data</a> for further discussion of
how to use this routine.

<p>
<font size="+1"><b><u>Load an image into a light window or a new (separate) window</u></b></font>
<p>
<code><font size="+1">JS9.LoadWindow(url, opts, type, html, winopts)</font></code>
<p>
where:
<ul>
<li><b>url</b>: url to load
<li><b>opts</b>: optional object containing image parameters and/or the div id
<li><b>type</b>: "light" or "new" 
<li><b>html</b>: html for the new page (default is to display a menubar above the image)
<li><b>winopts</b>: for "light", optional dhtml window options
</ul>
returns:
<ul>
<li><b>id</b>: the id of the JS9 display div
</ul>
This routine will load an image into a light-weight window or an entirely new
window. The <b>url</b> and <b>opts</b> arguments are identical to the standard
<b>JS9.Load()</b> call, except that <b>opts</b> can contain an <b>id</b>
string to specify the id of the JS9 div being created. If no id is specified,
a unique id is generated. In either case, the id is returned by the call.
<p>
The <b>type</b> argument determines whether to create
a light-weight window or a new (separate) window.
<p>
By default, the new window will contain a Menubar above an image display area:
<pre>
    &lt;div class='JS9Menubar' id='[id]Menubar'&gt;&lt;/div&gt;
    &lt;div class='JS9' id='[id]'&gt;&lt;/div&gt;
</pre>
You can use the <b>html</b> argument to supply different Web page elements
for the window. Furthermore, if you create a light window, a default
set of DynamicDrive dhtmlwindow parameters will be used to make the
window the correct size for the default html:
<pre>
    "width=512px,height=542px,center=1,resize=1,scrolling=1"
</pre>
You can supply your own parameters for the new dhtmlwindow using the
<b>winOpts</b> argument. See:
<a href="http://www.dynamicdrive.com/dynamicindex8/dhtmlwindow/index.htm">
DynamicDrive</a> for more information about their light-weight window.
<p>
See js9create.html for examples of how to use this routine.

<p>
<font size="+1"><b><u>Load an FITS image link into JS9 using a proxy server</u></b></font>
<p> 
<code><font size="+1">JS9.LoadProxy(url, opts)</font></code>
<p>
where:
<ul>
<li><b>url</b>: remote URL link to load
<li><b>opts</b>: object containing image parameters
</ul>
<p>
Load a FITS file specified by an arbitrary URL into JS9 using the
JS9 back-end helper as a proxy server.
<p>
For security reasons, JavaScript contained in one Web page can
access data in another Web page only if both Web pages have the
same origin (i.e., basically coming from the same host).  This
policy is called the 
<a href="https://en.wikipedia.org/wiki/Same-origin_policy">
Same Origin Policy</a>. This means that JS9 cannot load a FITS file from
an arbitrary URL without using special techniques.
<p>
One such technique is
<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">
Cross-Origin Resource Sharing</a>, by which the second server grants
permission to access its image data. Dropbox is CORS-enabled, so that
FITS files can be loaded directly into JS9. But obviously this requires
that explicit permission be granted by the other server.
<p>
A second technique is to use a proxy server: the URL is not
loaded directly into JS9, but instead is copied back to the
server from which JS9 itself was loaded. The file is then retrieved by
JS9 from this server so that the "same origin" rules are not violated.
<p>
The JS9 Node.js back-end helper can be configured to support
proxy server mode by setting the <b>JS9.globalOpts.loadProxy</b>
property. In addition, the back-end server must be configured to
support temporary working directories for each loaded page by setting
the <b>JS9.globalOpts.workDir</b> property. If the back-end server is
thus configured as a proxy server, JS9 will support the <b>JS9.LoadProxy()</b>
call and allow you to load FITS files from arbitrary URLs. JS9 also
will display a <b>open link via proxy</b> menu option in the <b>File</b> menu.
<p>
The <b>JS9.LoadProxy()</b> call takes a URL as its first
argument. This URL will be retrieved using curl or wget and stored on
the back-end server in a directory specifically tied to the Web
page. (The directory and its contents will be deleted when the page is
unloaded.) JS9 then will load the file from this directory. Note that
since the file resides on the back-end server, all back-end analysis 
defined on that server is available.
<p>
To override default image parameters, pass the image opts argument:
<pre>
    JS9.LoadProxy("http://hea-www.cfa.harvard.edu/~eric/coma.fits", {scale:"linear", colormap:"sls"});'
</pre>
<p>
If an onload callback function is specified in opts, it will be called
after the image is loaded:
<pre>
    JS9.LoadProxy("http://hea-www.cfa.harvard.edu/~eric/coma.fits", {scale: "linear", onload: func});'
</pre>
The image handle is passed as the first argument to the callback.
<p>
To load an image into a specified display, pass the <b>display object</b> as the last argument:
<pre>
    JS9.LoadProxy("http://hea-www.cfa.harvard.edu/~eric/coma.fits", {scale: "linear"}, {display: "myJS9"});'
</pre>
<p>
Note again that not all back-end servers support the proxy functionality.
The main 
<a href="http://js9.si.edu">JS9 Web site</a> does support proxy service, and
can be used to view images from arbitrary URLs.

<p>
<font size="+1"><b><u>Load one or more images when the Web page is ready</u></b></font>
<p>
<code><font size="+1">JS9.Preload(url1, opts1, url2, opts2, ... url2, optsn)</font></code>
<p>
where:
<ul>
<li><b>url</b>: url to load
<li><b>opts</b>: optional object containing image parameters
</ul>
This routine will pre-load images into a JS9 display. It can be added
to the Web page body element using the onload() JavaScript call or
called in a JavaScript init routine tied to onload. See index.html and
js9preload.html for examples.
<p>
It is worth emphasizing that <b>JS9.Preload()</b> should not be called
until the Web page is fully loaded, since JS9 itself is not fully
initialized until then. It is for this reason that <b>JS9.Preload()</b>
generally is called using an onload routine tied to the Web page body.
  
<p>
<font size="+1"><b><u>Get Load Status</u></b></font>
<p> 
<code><font size="+1">status = JS9.GetLoadStatus(id)</font></code>
<p>
where:
<ul>
<li><b>id</b>: the id of the file that was loaded into JS9
</ul>
returns:
<ul>
<li><b>status</b>: status of the load
</ul>
This routine returns the status of the load process for this image. A
status of "complete" means that the image is fully loaded. Other statuses
include:
<ul>
<li> loading: the image is in process of loading
<li> error: image did not load due to an error
<li> other: another image is loaded into this display
<li> none: no image is loaded into this display
</ul>
Thus, to check for image load, one can do this in python:
<pre>
    tfits = "foo.fits"
    hdul = fits.open(tfits)
    ...
    j = JS9()
    j.SetFITS(hdul, tfits)
    while j.GetLoadStatus(tfits) != "complete":
        time.sleep(0.1)
    j.SetZoom(2)
</pre>

<hr><p>
<center><b><font size="+1">
<a name="images">Working with Images</a>
</font></b></center>
<p>

<p>
<font size="+1"><b><u>Get image handle for the current image</u></b></font>
<p>
<code><font size="+1">im = JS9.GetImage()</font></code>
<p>
returns:
<ul>
<li><b>im</b>: image handle
</ul>
<p>
The routine returns the image handle associated with the current image.
<p>
The returned image handle can be passed in the display object.  This
is marginally more efficient than the default behavior, which is to
determine the current image for each call.

<p>
<font size="+1"><b><u>Get image data and auxiliary info for the specified image</u></b></font>
<p>
<code><font size="+1">imdata = JS9.GetImageData(dflag)</font></code>
where:
<ul>
<li><b>dflag</b>: specifies whether the data should also be returned
</ul>
<p>
returns:
<ul>
<li><b>imdata</b>: image data object
</ul>
<p>
The image data object contains the following information:
<ul>
<li><b>id</b>: the id of the file that was loaded into JS9
<li><b>file</b>: the file or URL that was loaded into JS9
<li><b>fits</b>: the FITS file associated with this image
<li><b>source</b>: "fits" if a FITS file was downloaded, "fits2png" if a representation file was retrieved
<li><b>imtab</b>: "image" for FITS images and png files, "table" for FITS binary tables
<li><b>width</b>: x dimension of image
<li><b>height</b>: y dimension of image
<li><b>bitpix</b>: FITS bits/pixel of each image element (8 for unsigned char, 16, 32 for signed integer, -32 or -64 for float)
<li><b>header</b>: JavaScript object containing FITS header values
<li><b>data</b>: buffer containing raw data values
</ul>
This call can return raw data for subsequent use in local analysis
tasks. The format of the returned data depends on the exact value
of <b>dflag</b>. If <b>dflag</b> is the boolean value true, an HTML5
typed array is returned. In JavaScript, typed arrays are more
efficient than ordinary JavaScript arrays, and, in this case, the
returned data is actually just reference to the real JS9 image data
(so be careful about changing values).
<p>
If <b>dflag</b> is the string "array", a JavaScript array is returned.
This is not a reference to the real data and will utilize
additional memory, but the values can be manipulated safely.
<p>
If <b>dflag</b> is the string "base64", a base64-encoded string is
returned.  Oddly, this seems to be the fastest method of transferring
data to via socket.io an external process such as Python, and, in fact, 
is the method used by the pyjs9.py interface. (The "array" method also can 
be used, but seems to be slower.)

<p>
The <b>file</b> value can be a FITS file or a representation PNG file. The
<b>fits</b> value will be the path of the FITS file associated with
this image. For a presentation PNG file, the path generally will be
relative to the JS9 install directory. For a normal FITS file, the path
usually is an absolute path to the FITS file.
<p>
If you are calling <b>JS9.GetImageData()</b> from an external process (via
the msg protocol), you almost certainly want to set <b>dflag</b> to "array". 
Doing so will serialize the data as an array instead of as an object, saving
a considerable amount of transfer data.
<p>
Given a FITS-standard 1-indexed image pixel x,y, you can find the data value 
at that location using:
<pre>
    val = obj.data[Math.floor(y-0.5) * obj.width + Math.floor(x-0.5)];
</pre>
Note the need to integerize the x and y values: JavaScript arrays are
objects and so floating point array indices do not get truncated
automatically as in C. They will return null values.
<p>
Also note that since we need 0-based data array indexes, we subtract 1 from
the 1-based image position.  But then we must add 0.5 before rounding because
by convention, x.0, y.0 is the middle of the pixel.
<p>
<font size="+1"><b><u>Display an image</u></b></font>
<p>
<code><font size="+1">JS9.DisplayImage(step)</font></code>
<p>
where:
<ul>
<li><b>step</b>: starting step to take when displaying the image
</ul>
The display steps are: "colors" (remake color data when cmap has changed),
"scaled" (rescale data values), "primary" (convert scaled data values
to color values), and "display" (write color values to the Web page).
<p>
The default step is "primary", which displays the image without recalculating
color data, scaled data, etc. This generally is what you want, unless you have
explicitly changed parameter(s) used in a prior step.

<p>
<font size="+1"><b><u>Re-read the image data and re-display</u></b></font>
<p>
<code><font size="+1">JS9.RefreshImage(input, func)</font></code>
<p>
where:
<ul>
<li><b>input</b>: object, javascript array, typed array, or FITS blob
<li><b>func</b>: optional function to call when image refresh is complete
</ul>
This routine can be used, for example, in laboratory settings where
data is being gathered in real-time and the JS9 display needs to be
refreshed periodically. The first <b>input</b> argument can be one of the following:
<ul>
<li> a javascript array containing raw data
<li> a typed array containing raw data
<li> a blob containing a FITS file
<li> an object containing a required <b>image</b> property and any of the
following optional properties: 
<ul>
<li><b>naxis</b>: number of axes in the image
<li><b>axis</b>: array of image dimensions for each axis or ...
<li><b>naxis[n]</b>: image dimensions of each axis (naxis1, naxis2, ...)
<li><b>bitpix</b>: FITS bitpix value
<li><b>head</b>: object containing header keywords as properties
<li><b>dmin</b>: data min (optional)
<li><b>dmax</b>: data max (optional)
</ul>
</ul>
When passing an object as <b>input</b>, the required <b>image</b>
property containing the image data can be a javascript array or a
typed data array. It also can contain a base64-encoded string
containing an array. This latter can be useful when calling
JS9.RefreshImage() via HTTP.
<p>
Ordinarily, when refreshing an image, there is no need to specify the
optional axis, bitpix, or header properties.  But note that you actually
can change these values on the fly, and JS9 will process the new data
correctly.  Also, if you do not pass <b>dmin</b> or <b>dmax</b>, they
will be calculated by JS9.
<p>
Note that you can pass a <b>blob</b> containing a complete FITS file to this
routine. The blob will be passed to the underlying FITS-handler before
being displayed. Thus, processing time is slightly greater than if you just
pass the image data directly.
<p>
The main difference between <b>JS9.RefreshImage()</b>
and <b>JS9.Load()</b> is that the former updates the data into an
existing image, while the latter adds a completely new image to the
display.
<p>
<font size="+1"><b><u>Clear the image from the display and mark resources for release</u></b></font>
<p>
<code><font size="+1">JS9.CloseImage()</font></code>
<p>
Each loaded image claims a non-trivial amount of memory from a finite
amount of browser heap space. For example, the default 32-bit version
of Google Chrome has a memory limit of approximately 500Mb. If you are
finished viewing an image, closing it tells the browser that the
image's memory can be freed. In principle, this is can help reduce
overall memory usage as successive images are loaded and
discarded. Note, however, that closing an image only provides a hint
to the browser, since this sort of garbage collection is not directly
accessible to JavaScript programming.
<p>
Some day, all browsers will support full 64-bit addressing and this problem will
go away ...
<p>
<font size="+1"><b><u>Get the image colormap</u></b></font>
<p>
<code><font size="+1">cmap = JS9.GetColormap()</font></code>
<p>
returns:
<ul>
<li><b>cmap</b>: object containing colormap information
</ul>
The returned cmap object will contain the following properties:
<ul>
<li><b>colormap</b>: colormap name
<li><b>contrast</b>: contrast value (range: 0 to 10)
<li><b>bias</b>: bias value (range 0 to 1)
</ul>

<p>
<font size="+1"><b><u>Set the image colormap</u></b></font>
<p>
<code><font size="+1">JS9.SetColormap(colormap, [contrast, bias])</font></code>
<p>
where:
<ul>
<li><b>colormap</b>: colormap name
<li><b>contrast</b>: contrast value (range: 0 to 10)
<li><b>bias</b>: bias value (range 0 to 1)
</ul>
Set the current colormap, contrast/bias, or both. This call takes one
(colormap), two (contrast, bias) or three (colormap, contrast, bias)
arguments.

<p>
<font size="+1"><b><u>Get the image scale</u></b></font>
<p>
<code><font size="+1">scale = JS9.GetScale()</font></code>
<p>
returns:
<ul>
<li><b>scale</b>: object containing scale information
</ul>
The returned scale object will contain the following properties:
<ul>
<li><b>scale</b>: scale name
<li><b>scalemin</b>: min value for scaling
<li><b>scalemax</b>: max value for scaling
</ul>

<p>
<font size="+1"><b><u>Set the image scale</u></b></font>
<p>
<code><font size="+1">JS9.SetScale(scale, smin, smax)</font></code>
<p>
where:
<ul>
<li><b>scale</b>: scale name
<li><b>smin</b>: scale min value
<li><b>smax</b>: scale max value
</ul>
Set the current scale, min/max, or both. This call takes one
(scale), two (smin, max) or three (scale, smin, smax) arguments.

<p>
<font size="+1"><b><u>Get the image zoom factor</u></b></font>
<p>
<code><font size="+1">zoom = JS9.GetZoom()</font></code>
<p>
returns:
<ul>
<li><b>zoom</b>: floating point zoom factor
</ul>
Get the zoom factor.

<p>
<font size="+1"><b><u>Set the image zoom factor</u></b></font>
<p>
<code><font size="+1">JS9.SetZoom(zoom)</font></code>
<p>
where:
<ul>
<li><b>zoom</b>: floating or integer zoom factor or zoom directive string
</ul>
The zoom directives are:
<ul>
<li><b>x[n]|X[n]</b>: multiply the zoom by n (e.g. "x2")
<li><b>/[n]</b>: divide the zoom by n (e.g. "/2")
<li><b>in|In</b>: zoom in by a factor of two
<li><b>out|Out</b>: zoom out by a factor of two
<li><b>toFit|ToFit</b>: zoom to fit image in display
</ul>

<p>
<font size="+1"><b><u>Get the image pan position</u></b></font>
<p>
<code><font size="+1">ipos = JS9.GetPan()</font></code>
<p>
returns:
<ul>
<li><b>ipos</b>: object containing image information for pan
</ul>
The returned ipos object will contain the following properties:
<ul>
<li><b>x</b>: x image coordinate of center
<li><b>y</b>: y image coordinate of center
</ul>

<p>
<font size="+1"><b><u>Set the image pan position</u></b></font>
<p>
<code><font size="+1">JS9.SetPan(x, y)</font></code>
<p>
where:
<ul>
<li><b>x</b>: x image coordinate
<li><b>y</b>: y image coordinate
</ul>
Set the current pan position using image coordinates.  
Note that you can use <b>JS9.WCSToPix()</b> and <b>JS9.PixToWCS()</b> to
convert between image and WCS coordinates.

<p>
<font size="+1"><b><u>Get the display coordinates from an event</u></b></font>
<p>
<code><font size="+1">dpos = JS9.EventToDisplayPos(evt)</font></code>
<p>
where:
<ul>
<li><b>evt</b>: a JavaScript event
</ul>
returns:
<ul>
<li><b>dpos</b>: display position object containing x and y display
coordinate values
</ul>
If you define your own event callbacks, you can use this routine to convert
the event position to a display position, which can then be used to get the
image position (see below).

<p>
<font size="+1"><b><u>Get the image coordinates from the display coordinates</u></b></font>
<p>
<code><font size="+1">ipos = JS9.DisplayToImagePos(dpos)</font></code>
<p>
where:
<ul>
<li><b>dpos</b>: display position object containing x and y display
coordinate values
</ul>
returns:
<ul>
<li><b>ipos</b>: image position object containing x and y image
coordinate values
</ul>
Note that image coordinates are one-indexed, as per FITS conventions, while
display coordinate are 0-indexed.

<p>
<font size="+1"><b><u>Get the display coordinates from the image coordinates</u></b></font>
<p>
<code><font size="+1">dpos = JS9.ImageToDisplayPos(ipos)</font></code>
<p>
where:
<ul>
<li><b>ipos</b>: image position object containing x and y image
coordinate values
</ul>
returns:
<ul>
<li><b>dpos</b>: display position object containing x and y display
coordinate values
</ul>
Get display (screen) coordinates from image coordinates.  Note that
image coordinates are one-indexed, as per FITS conventions, while
display coordinate are 0-indexed.

<p>
<font size="+1"><b><u>Get the image coordinates from the logical coordinates</u></b></font>
<p>
<code><font size="+1">ipos = JS9.LogicalToImagePos(lpos, lcs)</font></code>
<p>
where:
<ul>
<li><b>lpos</b>: logical position object containing x and y logical
coordinate values
</ul>
returns:
<ul>
<li><b>ipos</b>: image position object containing x and y image
coordinate values
</ul>
Logical coordinate systems include: "physical" (defined by LTM/LTV keywords in a
FITS header), "detector" (DTM/DTV keywords), and "amplifier" (ATM/ATV keywords).
Physical coordinates are the most common. In the world of X-ray astronomy, they
refer to the "zoom 1" coordinates of the data file.

<p>
This routine will convert from logical to image coordinates. By default, the
current logical coordinate system is used. You can specify a different logical
coordinate system (assuming the appropriate keywords have been defined).

<p>
<font size="+1"><b><u>Get the logical coordinates from the image coordinates</u></b></font>
<p>
<code><font size="+1">lpos = JS9.ImageToLogicalPos(ipos, lcs)</font></code>
<p>
where:
<ul>
<li><b>ipos</b>: image position object containing x and y image
coordinate values
</ul>
returns:
<ul>
<li><b>lpos</b>: logical position object containing x and y logical
coordinate values
</ul>
Logical coordinate systems include: "physical" (defined by LTM/LTV keywords in a
FITS header), "detector" (DTM/DTV keywords), and "amplifier" (ATM/ATV keywords).
Physical coordinates are the most common. In the world of X-ray astronomy, they
refer to the "zoom 1" coordinates of the data file.
<p>
This routine will convert from image to logical coordinates. By default, the
current logical coordinate system is used. You can specify a different logical
coordinate system (assuming the appropriate keywords have been defined).

<p>
<font size="+1"><b><u>Get value/position information</u></b></font>
<p>
<code><font size="+1">valpos = JS9.GetValPos(ipos, display)</font></code>
<p>
where:
<ul>
<li><b>ipos</b>: image position object containing x and y image coord values
<li><b>display</b>: boolean value specifying whether the info box display should be updated (default is true)
</ul>
returns:
<ul>
<li><b>valpos</b>: value/position object
</ul>
This routine determines the data value at a given image position
and returns an object containing the following information:
<ul>
<li><b>ix</b>: image x coordinate
<li><b>iy</b>: image y coordinate
<li><b>isys</b>: image system (i.e. "image")
<li><b>px</b>: physical x coordinate
<li><b>py</b>: physical y coordinate
<li><b>psys</b>: currently selected pixel-based system (i.e. "image"
or "physical") for the above px, py values
<li><b>ra</b>: ra in degrees (if WCS is available)
<li><b>dec</b>: dec in degrees  (if WCS is available)
<li><b>wcssys</b>: wcs system (if WCS is available)
<li><b>val</b>: floating point pixel value
<li><b>val3</b>: pixel value as a string truncated to 3 decimal digits
<li><b>vstr</b>: string containing value and position info
<li><b>id</b>: id of the image
<li><b>file</b>: filename of the image
<li><b>object</b>: object name of the image from the FITS header
</ul>

<p>
<font size="+1"><b><u>Set the value/position display mode</u></b></font>
<p>
<code><font size="+1">JS9.SetValPos(mode)</font></code>
<p>
where:
<ul>
<li><b>mode</b>: true (show valpos display) or false (hide valpos display)
</ul>
Set the display mode of the value/position display for the specified image.

<p>
<font size="+1"><b><u>Get the current WCS units</u></b></font>
<p>
<code><font size="+1">unitsstr = JS9.GetWCSUnits()</font></code>
<p>
returns:
<ul>
<li><b>unitstr</b>: "pixels", "degrees" or "sexagesimal"
</ul>
Get the current WCS units.

<p>
<font size="+1"><b><u>Set the current WCS units</u></b></font>
<p>
<code><font size="+1">JS9.SetWCSUnits(unitsstr)</font></code>
<p>
where:
<ul>
<li><b>unitstr</b>: "pixels", "degrees" or "sexagesimal"
</ul>
Set the current WCS units.

<p>
<font size="+1"><b><u>Get the current World Coordinate System</u></b></font>
<p>
<code><font size="+1">sysstr = JS9.GetWCSSys()</font></code>
<p>
returns:
<ul>
<li><b>sysstr</b>: current World Coordinate System ("FK4", "FK5", "ICRS",
"galactic", "ecliptic", "image", or "physical");
</ul>
Get current WCS system.

<p>
<font size="+1"><b><u>Set the current World Coordinate System</u></b></font>
<p>
<code><font size="+1">JS9.SetWCSSys(sysstr)</font></code>
<p>
where:
<ul>
<li><b>sysstr</b>: World Coordinate System ("FK4", "FK5", "ICRS",
"galactic", "ecliptic", "image", or "physical")
</ul>
Set current WCS system. The WCS systems are available only if WCS
information is contained in the FITS header. Also note that "physical"
coordinates are the coordinates tied to the original file. They are
mainly used in X-ray astronomy where individually detected photon
events are binned into an image, possibly using a blocking factor.
For optical images, image and physical coordinate usually are identical.

<p>
<font size="+1"><b><u>Convert image pixel position to WCS position</u></b></font>
<p>
<code><font size="+1">wcsobj = JS9.PixToWCS(x, y)</font></code>
<p>
where:
<ul>
<li><b>x</b>: x image coordinate
<li><b>y</b>: y image coordinate
</ul>
returns:
<ul>
<li><b>wcsobj</b>: world coordinate system object
</ul>
<p>
The wcs object contains the following properties:
<ul>
<li><b>ra</b>: right ascension in floating point degrees
<li><b>dec</b>: declination in floating point degrees 
<li><b>sys</b>: current world coordinate system being used
<li><b>str</b>: string of wcs in current system ("[ra] [dec] [sys]")
</ul>

<p>
<font size="+1"><b><u>Convert WCS position to image pixel position</u></b></font>
<p>
<code><font size="+1">pixobj = JS9.WCSToPix(ra, dec)</font></code>
<p>
where:
<ul>
<li><b>ra</b>: right ascension in floating point degrees
<li><b>dec</b>: declination in floating point degrees 
</ul>
returns:
<ul>
<li><b>pixobj</b>: pixel object
</ul>
The pixel object contains the following properties:
<ul>
<li><b>x</b>: x image coordinate
<li><b>y</b>: y image coordinate
<li><b>str</b>: string of pixel values ("[x]" "[y]")
</ul>

<p>
<font size="+1"><b><u>Display a text message</u></b></font>
<p>
<code><font size="+1">JS9.DisplayMessage(which, text)</font></code>
<p>
where:
<ul>
<li><b>which</b>: "info" or "regions"
<li><b>text</b>: text to display
</ul>
The text string is displayed in the "info" area (usually occupied by the
valpos display) or the "region" area (where regions are displayed). The
empty string will clear the previous message.

<hr><p>
<center><b><font size="+1">
<a name="regions">Working with Regions</a>
</font></b></center>
<p>
Spatial regions of interest are a crucial part of astronomical data
analysis.  The regions layer is a special case of the more generalized
shape layers, automatically created by JS9 to support the options in
the <b>Regions</b> menu, as well as local and server-side data analysis
using regions.
<p>
The regions layer has the special property that, by default,
its <b>z-index</b> is higher than other shape layers, so that regions
are displayed on top of other shape layers.
<p>
Note that the <b>GetRegions(), ChangeRegions(), RemoveRegions()</b> calls
all take a regions specification as the second argument, which can be
any of the following (in order of precedence):
<ul>
<li><b>"all"</b>: all regions
<li><b>[id]</b>: a specific region id returned by <b>JS9.AddRegions()</b>
<li><b>"selected"</b>: the selected region (or all regions in the selected group)
<li><b>[color]</b>: all regions having the specified color (e.g., "red")
<li><b>[shape]</b>: all regions having the specified shape (e.g., "circle")
<li><b>[tag]</b>: all regions containing the specified tag (e.g., "source")
</ul>
Thus, it is possible to act on multiple regions at the same time.

<p>
<font size="+1"><b><u>Add one or more regions to the regions layer</u></b></font>
<p>
<code><font size="+1">id = JS9.AddRegions(rarr, opts)</font></code>
<p>
where:
<ul>
<li><b>rarr</b>: a shape string, region object or an array of region objects
<li><b>opts</b>: global values to apply to each created region
</ul>
returns:
<ul>
<li><b>id</b>: id of last region created
</ul>
The <b>rarr</b> argument can be a region shape ("annulus", "box",
"circle", "ellipse", "point", "polygon", "text"), a single region
object, or an array of region objects. Region objects contain one or
more properties, of which the most important are:
<ul>
<li><b>shape</b>: "annulus", "box", "circle", "ellipse", "point", "polygon", "text" <b>[REQUIRED]</b>
<li><b>x</b>: image x position
<li><b>y</b>: image y position
<li><b>lcs</b>: object containing logical x, y and sys (e.g. "physical")
<li><b>dx</b>: increment from current image x position
<li><b>dy</b>: increment from current image y position
<li><b>tags</b>: comma separated list of tag strings
<li><b>radii</b>: array of radii for annulus region
<li><b>width</b>: width for box region
<li><b>height</b>: height for box region
<li><b>radius</b>: radius value for circle region
<li><b>r1</b>:  x radius for ellipse region (misnomer noted)
<li><b>r2</b>:  y radius for ellipse region (misnomer noted)
<li><b>pts</b>: array of objects containing x and y positions for polygons
<li><b>points</b>: array of objects containing x and y offsets from the center for polygons
<li><b>angle</b>: angle in degrees for box and ellipse regions
<li><b>color</b>: region color (string name or #rrggbb syntax)
<li><b>text</b>: text associated with text region
<li><b>data</b>: this property can be an object, string, number,
etc. and will be carried along with the region, and returned as a
property by the <b>JS9.GetRegions()</b> call.
</ul>
Other available properties include:
<ul>
<li><b>fixinplace</b>: if true, region cannot be moved or resized
<li><b>lockMovementX</b>: region cannot be moved in the x direction
<li><b>lockMovementY</b>: region cannot be moved in the y direction
<li><b>lockRotation</b>: region cannot be rotated
<li><b>lockScalingX</b>: region cannot be resized in the x direction
<li><b>lockScalingY</b>: region cannot be resized in the y direction
<li><b>fontFamily</b>: font parameter for text region
<li><b>fontSize</b>: font parameter for text region
<li><b>fontStyle</b>: font parameter for text region
<li><b>fontWeight</b>: font parameter for text region
</ul>

<p>
<font size="+1"><b><u>Get information about one or more regions</u></b></font>
<p>
<code><font size="+1">rarr = JS9.GetRegions(regions)</font></code>
<p>
where:
<ul>
<li><b>regions</b>: which regions to retrieve
</ul>
returns:
<ul>
<li><b>rarr</b>: array of region objects
</ul>
<p>
Each returned region object contains the following properties:
<ul>
<li><b>id</b>: numeric region id (assigned by JS9 automatically)
<li><b>mode</b>: "add", "remove" or "change"
<li><b>shape</b>: region shape ("annulus", "box", "circle", "ellipse",
"point", "polygon", "text")
<li><b>tags</b>: comma delimited list of region tags (e.g., "source", "include")
<li><b>color</b>: region color
<li><b>x,y</b>: image coordinates of region
<li><b>radii</b>: array of radii for annulus region
<li><b>width</b>: width for box region
<li><b>height</b>: height for box region
<li><b>radius</b>: radius value for circle region
<li><b>r1</b>:  x radius for ellipse region (misnomer noted)
<li><b>r2</b>:  y radius for ellipse region (misnomer noted)
<li><b>pts</b>: array of objects containing x and y positions, for polygons
<li><b>points</b>: array of objects containing x and y offsets from the specified center, for polygons
<li><b>angle</b>: angle in degrees for box and ellipse regions
<li><b>wcsstr</b>: region string in wcs coordinates
<li><b>wcssys</b>: wcs system (e.g. "FK5")
<li><b>imstr</b>: region string in image or physical coordinates
<li><b>imsys</b>: image system ("image" or "physical")
<li><b>data</b>: data property passed in options object when this shape was created.
</ul>
The image position can be used to access the image data returned by the
<b>JS9.GetImageData()</b> routine:
<pre>
    obj = JS9.GetImageData();
    xreg = JS9.GetRegions("selected")[0];
    val = obj.data[Math.floor(xreg.y-0.5) * obj.width + Math.floor(xreg.x-0.5)];
</pre>
<p>
Note the need to integerize the x and y values: JavaScript arrays are
objects and so floating point array indices do not get truncated
automatically as in C. They will return null values.
<p>
Also note that since we need 0-based data array indexes, we subtract 1 from
the 1-based image position.  But then we must add 0.5 before rounding because
by convention, x.0, y.0 is the middle of the pixel.

<p>
<font size="+1"><b><u>Change one or more regions</u></b></font>
<p>
<code><font size="+1">JS9.ChangeRegions(regions, opts)</font></code>
<p>
where:
<ul>
<li><b>regions</b>: which regions to change
<li><b>opts</b>: object containing options to change in each region
</ul>
Change one or more regions. The opts object can contain the parameters 
described in the <b>JS9.AddRegions()</b> section. However, you cannot (yet)
change the shape itself (e.g. from "box" to "circle"). See js9onchange.html
for examples of how to use this routine.

<p>
<font size="+1"><b><u>Remove one or more regions from the region layer</u></b></font>
<p>
<code><font size="+1">JS9.RemoveRegions(regions)</font></code>
<p>
where:
<ul>
<li><b>regions</b>: which regions to remove
</ul>

<hr><p>
<center><b><font size="+1">
<a name="shapes">Working with Shape Layers</a>
</font></b></center>
<p>
JS9 supports individual layers for drawing 2D graphics. The regions
layer is a special case of a shape layer, created automatically by
JS9. The Catalog plugin creates a separate layer for each catalog.
You can define your own shape layer using the <b>NewShapeLayer()</b>
call and then add geometric shapes to it.
<p>
Note that the <b>JS9.GetShapes(), JS9.ChangeShapes(), JS9.RemoveShapes()</b> 
calls all take a shape specification as the second argument, which can
be any of the following (in order of precedence):
<ul>
<li><b>"all"</b>: all regions
<li><b>[id]</b>: a specific region id returned by <b>JS9.AddRegions()</b>
<li><b>"selected"</b>: the selected region (or all regions in the selected group)
<li><b>[color]</b>: all regions having the specified color (e.g., "red")
<li><b>[shape]</b>: all regions having the specified shape (e.g., "circle")
<li><b>[tag]</b>: all regions containing the specified tag (e.g., "source")
</ul>
Thus, it is possible to act on multiple shapes at the same time.

<p>
<font size="+1"><b><u>Create a new shape layer</u></b></font>
<p>
<code><font size="+1">lid = JS9.NewShapeLayer(layer, opts)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of the layer to create
<li><b>opts</b>: default options for this layer
</ul>
returns:
<ul>
<li><b>lid</b>: layer id
</ul>
This routine creates a new named shape layer. You can then, add, change,
and remove shapes in this layer using the routines below. The catalogs
displayed by the Catalog plugin are examples of separate shape layers.
<p>
The optional <b>opts</b> parameter allows you to specify default
options for the new layer. You can set a default for any property needed
by your shape layer. See JS9.Regions.opts in js9.js for example of the
default options for the regions layer.
<p>
The JS9.Catalogs.opts object is also supplied as a possible default
object for new shape layers.  It differs from the JS9.Regions.opts
object in that it does not define regions-specific processing (such as
double-click to edit a region parameters). It also makes the new layer
non-interactive: individual shapes cannot be moved, rotated, resized,
or deleted, nor do they respond to events.
<p>
Starting with the JS9.Catalogs.opts object as a default, you can make
the new layer interactive in a few different ways. The first way is to
set the <b>movable</b> property in the opts object to <b>true</b>.
This will permit individual shapes to be moved, rotated, resized and
deleted. Shapes also will be movable and resizeable as a group.
<p>
The second way is to supply one or more event callbacks as properties
to the opts object:
<ul>
<li> <b>onmousedown</b>: function(im, xreg, evt);
<li> <b>onmouseup</b>: function(im, xreg, evt);
<li> <b>onmousemove</b>: function(im, xreg, evt);
<li> <b>onmouseover</b>: function(im, xreg, evt);
<li> <b>onmouseout</b>: function(im, xreg, evt);
</ul>
When the associated mouse event occurs on a shape, these functions
will be called with the following arguments:
<ul>
<li> <b>im</b>: the image handle for the currently displayed image
<li> <b>xreg</b>: the shape object, as described in JS9.GetShapes()
<li> <b>evt</b>: the original event object
</ul>
For example, to define mouseover and mousedown callbacks:
<pre>
    opts.onmouseover = function(im, xreg, evt){
        console.log("mouseover: %s %s", im.id, xreg.data.tag);
    };
    opts.onmousedown = function(im, xreg, evt){
        console.log("mousedown: %s %s", im.id, xreg.data.tag);
</pre>
Note that the shapes are still not movable unless you also set
the <b>movable</b> property.
<p>
In addition to firing callbacks on events for individual shapes, you
can set the <b>ongroupcreate</b> property in the opts object to a
function that will fire when two or more objects are selected into a
group (which is done using the <b>Command</b> key on a Mac,
or <b>Control</b> key everywhere else):
<ul>
<li><b>ongroupcreate</b>: function(im, xregs, evt);
</ul>
The function will be called with the following arguments:
<ul>
<li> <b>im</b>: the image handle for the currently displayed image
<li> <b>xregs</b>: an array of shape objects within the group
<li> <b>evt</b>: the original event object
</ul>
Note that an array of xreg objects is passed in this case instead of
the single "current" object passed in the other event callbacks.
For example:
<pre>
    opts.ongroupcreate = function(im, xregs, evt){
        var i, nshape, xcen, ycen;
        var xtot=0, ytot=0;
        nshape = xregs.length;
        for(i=0; i&lt;nshape; i++){
          xtot += xregs[i].x; ytot += xregs[i].y;
        }
        xcen = xtot / nshape; ycen = ytot / nshape;
        console.log("average pos for %s objects: %s,%s", nshape, xcen, ycen);
    }
</pre>
<p>
The final way to make a shape layer interactive is to specify
a <b>tooltip</b> to display when hovering over objects in this shape
layer. This is done by assigning a tooltip format string to
the <b>tooltip</b> property of the opts object.  This string can
contain HTML directives, and it also can contain references to
properties in the im, xreg, and evt objects. When the mouse hovers
over an object, a tooltip string is generated by macro-expanding the
values for these properties. The generated tooltip string is displayed
as the inner HTML of the tooltip. When the mouse leaves the object,
the tooltip is hidden.
<p>
For example, consider the following tooltip string:
<pre>
    opts.tooltip = "&lt;b&gt;id: $im.id&lt;/b&gt;&lt;br&gt;pos: $xreg.x $xreg.y&lt;br&gt;&lt;i&gt;$xreg.data.tag&lt;/i&gt;";
</pre>
Note how properties of the <b>im</b> and <b>xreg</b> objects are
specified with a "$" prefix. When the mouse hovers over an object, the
generated tooltip will display current image id in bold, followed by
that object's x,y pixel position, followed by a user <b>tag</b>
property passed in the <b>data</b> object when the shape was added.
<p>
<font size="+1"><b><u>Show or hide the specified shape layer</u></b></font>
<p>
<code><font size="+1">JS9.ShowShapeLayer(layer, mode)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of layer
<li><b>mode</b>: true (show layer) or false (hide layer)
</ul>
Shape layers can be hidden from display. This could be useful, for
example, if you have several catalogs loaded into a display and
want to view one at a time.

<p>
<font size="+1"><b><u>Add one or more shapes to the specified layer</u></b></font>
<p>
<code><font size="+1">JS9.AddShapes(layer, sarr, opts)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of layer
<li><b>sarr</b>: a shape string, shape object, or an array of shape objects
<li><b>opts</b>: global values to apply to each created shape
</ul>
returns:
<ul>
<li><b>id</b>: id of last shape created
</ul>
The <b>sarr</b> argument can be a shape ("annulus", "box",
"circle", "ellipse", "point", "polygon", "text"), a single shape
object, or an array of shape objects. Shape objects contain one or
more properties, of which the most important are:
<ul>
<li><b>shape</b>: "annulus", "box", "circle", "ellipse", "point", "polygon", "text" <b>[REQUIRED]</b>
<li><b>x</b>: image x position
<li><b>y</b>: image y position
<li><b>dx</b>: increment from current image x position
<li><b>dy</b>: increment from current image y position
<li><b>tags</b>: comma separated list of tag strings
<li><b>radii</b>: array of radii for annulus shape
<li><b>width</b>: width for box shape
<li><b>height</b>: height for box shape
<li><b>radius</b>: radius value for circle shape
<li><b>r1</b>:  x radius for ellipse shape (misnomer noted)
<li><b>r2</b>:  y radius for ellipse shape (misnomer noted)
<li><b>pts</b>: array of objects containing x and y positions, for polygons
<li><b>points</b>: array of objects containing x and y offsets from the specified center, for polygons
<li><b>angle</b>: angle in degrees for box and ellipse shapes
<li><b>color</b>: shape color (string name or #rrggbb syntax)
<li><b>text</b>: text associated with text shape
<li><b>data</b>: this property can be an object, string, number,
etc. and will be carried along with the shape, and returned as a
property by the <b>JS9.GetShapes()</b> call.
</ul>
Other available properties include:
<ul>
<li><b>fixinplace</b>: if true, shape cannot be moved or resized
<li><b>lockMovementX</b>: shape cannot be moved in the x direction
<li><b>lockMovementY</b>: shape cannot be moved in the y direction
<li><b>lockRotation</b>: shape cannot be rotated
<li><b>lockScalingX</b>: shape cannot be resized in the x direction
<li><b>lockScalingY</b>: shape cannot be resized in the y direction
<li><b>fontFamily</b>: font parameter for text shape
<li><b>fontSize</b>: font parameter for text shape
<li><b>fontStyle</b>: font parameter for text shape
<li><b>fontWeight</b>: font parameter for text shape
</ul>

<p>
<font size="+1"><b><u>Remove one or more shapes from the specified shape layer</u></b></font>
<p>
<code><font size="+1">JS9.RemoveShapes(layer, shapes)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of layer
<li><b>shapes</b>: which shapes to remove
</ul>

<p>
<font size="+1"><b><u>Get information about one or more shapes in the specified shape layer</u></b></font>
<p>
<code><font size="+1">JS9.GetShapes(layer, shapes)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of layer
<li><b>shapes</b>: which shapes to retrieve
</ul>
returns:
<ul>
<li><b>sarr</b>: array of shape objects
</ul>
<p>
Each returned shape object contains the following properties:
<ul>
<li><b>id</b>: numeric region id (assigned by JS9 automatically)
<li><b>mode</b>: "add", "remove", or "change"
<li><b>shape</b>: region shape ("annulus", "box", "circle", "ellipse",
"point", "polygon", "text")
<li><b>tags</b>: comma delimited list of region tags (e.g., "source", "include")
<li><b>color</b>: region color
<li><b>x,y</b>: image coordinates of region
<li><b>size</b>: object containing width and height for box region
<li><b>radius</b>: radius value for circle region
<li><b>radii</b>: array of radii for annulus region
<li><b>eradius</b>: object containing x and y radii for ellipse regions
<li><b>pts</b>: array of objects containing x and y positions, for polygons
<li><b>angle</b>: angle in degrees for box and ellipse regions
<li><b>data</b>: data property passed in options object when this shape was created.
</ul>

<p>
<font size="+1"><b><u>Change one or more shapes in the specified layer</u></b></font>
<p>
<code><font size="+1">JS9.ChangeShapes(layer, shapes, opts)</font></code>
<p>
where:
<ul>
<li><b>layer</b>: name of layer
<li><b>shapes</b>: which shapes to change
<li><b>opts</b>: object containing options to change in each shape
</ul>
Change one or more shapes. The opts object can contain the parameters 
described in the <b>JS9.AddShapes()</b> section. However, you cannot (yet)
change the shape itself (e.g. from "box" to "circle").

<hr><p>
<center><b><font size="+1">
<a name="server">Server-side Analysis</a>
</font></b></center>
<p>

<p>
<font size="+1"><b><u>Run a simple server-side analysis task</u></b></font>
<p>
<code><font size="+1">JS9.RunAnalysis(name, parr, func)</font></code>
<p>
where:
<ul>
<li><b>name</b>: name of analysis tool
<li><b>parr</b>: optional array of macro-expansion options for command line
<li><b>func</b>: optional routine to call when analysis is completed on server
</ul>
The <b>JS9.RunAnalysis()</b> routine is used to execute a server-side
analysis task and return the results for further processing within the
Web page.
The optional <b>parr</b> array of parameters is passed to the JS9
analysis macro expander so that values can be added to the command
line.  The array is in jQuery name/value serialized object format,
which is described here:
<pre>
    http://api.jquery.com/serializeArray/
</pre>
<p>
The <b>func()</b> routine is a callback function to process the returned
results from the analysis task.  The calling sequence is:
<pre>
    func(stdout, stderr, errcode, aobj)
</pre>
where:
<ul>
<li> <b>stdout</b>: a string containing the standard output from the task
<li> <b>stderr</b>: a string containing the standard error from the task
<li> <b>errcode</b>: error code value from the task or 0
<li> <b>aobj</b>: the analysis object from the js9Analysis.json file,
     containing, among other things, the important <b>rtype</b>:
     "text" or "plot"
</ul>
Typically, you would check stderr string first and issue an error
message if there is an error. Otherwise, the stdout string can be
processed based on the return type (rtype) property of the output
(e.g., "text" or "plot"). For plotting, you can use <b>flot</b>
functionality already loaded into JS9, or you can use your own chosen
plotting package.
<p>
If no <b>func</b> callback is specified, the default processing will
display "text" in a new light window.  If the return type is "plot",
the results are assumed to be in <b>flot</b> format and will be plotted.

<p>
<font size="+1"><b><u>Run a server-side analysis task, utilizing
parameters in a form</u></b></font>
<p>
<code><font size="+1">JS9.SubmitAnalysis(el, name, func)</font></code>
<p>
where:
<ul>
<li><b>el</b>: form element (unused at present)
<li><b>name</b>: name of analysis tool
<li><b>func</b>: optional routine to call when analysis is completed on server
</ul>
The <b>JS9.SubmitAnalysis()</b> routine is used to run an analysis
task with input parameters from a form. Typically used as
the <b>Run</b> button action in a form, it automatically serializes
the form values and passes them to the JS9 analysis macro expander so
that these values can be integrated into the analysis command line.
See js9analysis.html for a simple example.
<p>
The <b>func</b> callback is the same as for <b>JS9.RunAnalysis()</b> above.

<hr><p>
<center><b><font size="+1">
<a name="misc">Miscellaneous</a>
</font></b></center>
<p>

<p>
<font size="+1"><b><u>Resize the JS9 Display</u></b></font>
<p>
<code><font size="+1">JS9.ResizeDisplay(width, height, opts)</font></code>
<p>
where:
<ul>
<li><b>width</b>: new width of the display in HTML pixels
<li><b>height</b>: new height of the display in HTML pixels
<li><b>opts</b>: optional object containing resize parameters
</ul>
You can resize the JS9 display element by supplying new width and
height parameters. The div on the Web page will be resized and the
image will be re-centered in the new display. If the display size has
been increased, more of the image will be displayed as needed (up to
the new size of the display). For example, if the original display was
512x512 and you increase it to 1024x1024, a 1024x1024 image will now
be displayed in its entirety.
<p>
The opts object can contain the following properties:
<ul>
<li><b>resizeMenubar</b>: change the width of the menubar as well
</ul>
The default for <b>resizeMenubar</b> is <b>true</b>, so you only need
to pass this property if you do not want to perform the resize.

<p>
<font size="+1"><b><u>Print an image</u></b></font>
<p>
<code><font size="+1">JS9.Print()</font></code>
<p>
Print the currently displayed image. A new window is displayed
containing the image, along with regions and other graphical layers
(the 2D graphics having been converted to a re-scalable format).  The
standard Print dialog box also is displayed and can be used to print
this new window.  Dismiss both windows when you are finished.

<p>
<font size="+1"><b><u>Display help in a light window</u></b></font>
<p>
<code><font size="+1">JS9.DisplayHelp(name)</font></code>
<p>
where:
<ul>
<li><b>name</b>: name of a help file or url of a Web site to display
</ul>
The help file names are the property names in JS9.helpOpts (e.g., "user" for
the user page, "install" for the install page, etc.). Alternatively, you can
specify an arbitrary URL to display (just because).

<p>
<font size="+1"><b><u>Get location of JS9 installation directory</u></b></font>
<p>
<code><font size="+1">rpath = JS9.InstallDir(file)</font></code>
<p>
where:
<ul>
<li><b>file</b>: file or directory to convert
</ul>
returns:
<ul>
<li><b>rpath</b>: path of the file relative to the JS9 install directory
</ul>
Sometimes a plugin needs to load an auxiliary file inside the plugins
sub-directory. The Web page loading the plugin has an arbitrary
location relative to the JS9 install directory, so this routine
returns a relative path to the js9 install directory.

<p>
<font size="+1"><b><u>Send a message to a back-end server</u></b></font>
<p>
<code><font size="+1">JS9.Send(msg, obj, cb)</font></code>
<p>
where:
<ul>
<li><b>msg</b>: name of the msg, as defined in the back-end server
<li><b>obj</b>: object containing msg parameters
<li><b>cb</b>: callback to call when back-end server returns its results
</ul>
JS9 sends various internal messages to the back-end server using either
socket.io protocol (in the Node.js implementation) or CGI. For
example, when a remote analysis call is made, JS9 sends a message to the
back-end server detailing the task to call, parameters to pass, etc. Results
are then returned to JS9 for display. JS9 also sends messages to the
back-end server when a new image is displayed, when a FITS file is to 
be converted into a PNG representation file, etc.
<p>
Communication with the back-end is usually done behind the scenes and
need not concern users or application programmers. However, if you
write your own socket.io-based server, you might want to add
project-specific messages to your implementation. For example, a
Perl-based or Python-based server might add its own special messages
that execute Perl or Python commands within the server in response to
JS9 messages. In this case, you can use <b>JS9.Send()</b> to send a
message to these message handlers.
<p>
The <b>msg</b> name is the name of the message, as defined by the
server. By convention, an object is usually passed to the
message handler. JS9 will add a <b>dataPath</b> property to this
object to indicate the current list of directories in which to
search for data. All other properties are specific to the message being handled.
You can pass a null instead of an object and <b>JS9.Send()</b> will generate
a temporary object to hold the dataPath.
<p>
The <b>cb</b> function will be called if the message sends an
acknowledgment.  The arguments passed to this function call by the server
are specific to the message being handled.
<p>
For example, you can send a message to the back-end server to retrieve the
list of available analysis tasks and then display this list using the call:
<pre>
JS9.Send("getAnalysis", null, function(s){alert(s)});
</pre>
The "getAnalysis" message passes no parameters to the server. The
server returns a list of available analysis tasks in JSON format.

<p>
<font size="+1"><b><u>Add a JS9 display div and/or associated plugins</u></b></font>
<p>
<code><font size="+1">JS9.AddDivs(id1, id2, ...)</font></code>
<p>
where:
<ul>
<li><b>id1, id2, ...</b>: optional name(s) of new JS9 display div(s)
</ul>
You can add new JS9 displays and/or plugins dynamically. To do this, you
create the new divs, add them to the Web page, and then call this routine to
incorporate them into JS9.
<p>
The routine will accept a list of JS9 display divs to initialize.  If
all you are doing is adding one or more plugins to an existing display,
leave the argument list empty.
<p>
For example, to add a new JS9 display and menubar at the end of a Web
page and load an image into that display:
<pre>
  var html = "&lt;div class='JS9Menubar' id='myJS9Menubar'&gt;&lt;/div&gt;&lt;div class='JS9' id='myJS9'&gt;&lt;/div&gt;";
  // jquery append to end of page
  $(html).appendTo($("body"));
  // create the new JS9 display, with associated plugins
  JS9.AddDivs("myJS9");
  // just a standard load to that display
  JS9.Load("foo.fits", {scale: "log"}, {display: "myJS9"});
</pre>
See also <b>JS9.LoadWindow()</b> for a nice way to load images into a
light-weight or completely new window.

<hr>
<center><b><font size="+1">
<a name="proto">Prototype Routines (not ready for prime time)</a>
</font></b></center>
<p>
NB: The routines in this section are prototypes and therefore are
subject to change. Feel free to contact us to discuss your needs so
that we can gain a better understanding of is required in these cases.
<p>
<font size="+1"><b><u>Load an auxiliary file</u></b></font>
<p>
<code><font size="+1">JS9.LoadAuxFile(name, func)</font></code>
<p>
where:
<ul>
<li><b>name</b>: class name of auxiliary file to load
<li><b>func</b>: function to call once the file is loaded
</ul>
<p> It sometimes is desirable to process auxiliary files when an image
is first loaded.  Examples include overlaying an image mask on an
image, and pre-loading regions from a region file.
The <b>JS9.LoadAuxFile</b> prototypes this sort of functionality.
<p>
Auxiliary files are defined in the js9Prefs.json file by means of the
JS9.auxfiles array containing one or more auxfile objects.  Each
auxfile specification has the following properties:
<ul>
<li><b>type</b>: type of auxiliary file: currently "mask" or "region"
<li><b>name</b>: the class name of the auxiliary file
<li><b>image</b>: image (or template) for which this auxfile is valid
<li><b>url</b>: URL of the auxfile
</ul>
For example, the following defines two auxfiles:
<pre>
  "auxFiles":   [{"type":	     "mask",
		  "name":	     "sciencemasks",
		  "image": 	     "casa.*.png",
		  "url":	     "../myauxfiles/casa-mask.png"},
		 {"type":	     "regions",
		  "name":	     "scienceregions",
		  "image": 	     "casa.*.png",
		  "url":	     "../myauxfiles/casa.reg"}],
</pre>
Here, a mask auxfile and a regions auxfile are defined for Cas-A
dataset(s). These auxfiles are brought into play as follows:
<pre>
    // run this routine after loading each image
    function onImageLoad(im){
      JS9.LoadAuxFile("sciencemasks", function(im, aux){
        // if we succeed in loading the mask, set up the onchange callback
        im.onregionschange = regionOnChange;
        // view the image through the mask data
        im.maskData = aux.im.raw.data;
        // I mean now!
	im.displayImage("all");
      });
    JS9.LoadAuxFile("scienceregions");
  }

  // tell JS9 about the onload callback
  JS9.imageOpts.onload = onImageLoad;
</pre>
An onImageLoad function is defined that will try to load auxfiles of
types "sciencemasks" and "scienceregions". This routine is set to
be called whenever a new image is loaded.
<p>
On image load, when <b>JS9.LoadAuxFile()</b> is called, it looks in
the list of known auxfiles for an entry that matches both
the class name and the image name.  If found (in the example above,
for Cas-A datasets), the associated auxfile URL is loaded and
type-specific processing is performed:
<ul>
<li><b>masks</b>: the mask file is loaded into the Web page as an
off-screen image and an aux object is created as a property of the
image object. This aux object can be used for subsequent processing
(see below).
<li><b>regions</b>: the regions in the region file are created and
displayed on the image.
</ul>
Once the initial auxfile processing has been performed, the optional
callback function will be called. For the "mask" example above, the
onregionchange property is set to call a JavaScript function (not
shown here) whenever a region changes. The maskData property is set to
point to the raw data of the auxfile (i.e., aux.im.raw.data). Finally,
the image is re-displayed. Setting the maskData property and
redisplaying the image causes the auxfile's data to be displayed as an
opaque overlay on top of the currently displayed image.
<p>
As should be clear from the description above, considerable "black
magic" currently is involved when processing auxiliary files.
Visibility is required into the inner properties of the image
object. Please contact us if you want to work with auxiliary files, so
that we can continue to think about what is required for their support.


<hr><p>
<center><b><font size="+1">
<a name="proto">API Change History</a>
</font></b></center>
<p>
The JS9 Public API is meant to be stable and well-documented. If we are
forced to make an incompatible change to the API, it will be documented here.

<p><font size="+1"><b><u>
20141117: The Set routines now return "OK" instead of true on success
</u></b></font>
<p>
The public Set routines (<b>SetZoom()</b>, <b>SetColormap()</b>, etc)
were returning a boolean true when successful. This has been changed
to "OK", to make it clear that the return value is a status value,
not a boolean data value.

<p><font size="+1"><b><u>
20141028: callback function to RunAnalysis and SubmitAnalysis
</u></b></font>
<p>
Due to an oversight, the signature of the callback function supplied to
<b>RunAnalysis()</b> (and its derivative function, 
<b>SubmitAnalysis()</b>) was missing the errcode argument. 
To correct this mistake, the signature was changed from:
<pre>
    func(stdout, stderr, aobj)
</pre>
to:
<pre>
    func(stdout, stderr, errcode, aobj)
</pre>
See js9onchange.html for an example of using this callback function.

<hr><p>

<h5>Last updated: September 25, 2015</h5>
</div>

</body>
</html>
